---
format:
  html:
    respect-user-color-scheme: true
    theme:
        light: ["style/flatly_customizations.scss", "style/style-light-color-customizations.scss", "style/style-customizations.scss"]
        dark: ["style/darkly_customizations.scss", "style/style-dark-color-customizations.scss", "style/style-customizations.scss"]
---

<!-- TODO: split this long chapter into two (1. getting elements by label and 2. by position) -->

# Getting Elements of a Series by Position {#sec-series-get-elements-iloc-positions}

```{python}
import pandas as pd
```

## Getting a Single Element of a Series Using `.iloc` {#sec-series-elements-iloc-positions-get-single-element}

Imagine, that we want to index the `row_series` series by the *position* of the elements rather than by the index *label*.

```{python}
row_series = pd.Series(
    [1, 42, "run", 60],
    index=["Activity ID", "User ID", "Activity Type", "Duration in Minutes"]
)
```

We can do so using `.iloc` instead of `.loc`.

```{python}
row_series.iloc[3]
```

::: callout-note
The first element of a series always has the position `0` (not `1`). So position `3` is held by the *fourth* series element.
:::

Often, the index labels of series elements match their position in the series, as is the case for the elements in `durations_series`.

```{python}
durations_series = pd.Series(
    [60, 210, 120, 45],
    name="Duration in Minutes"
)
durations_series
```

Hence, it does not matter whether we use `.loc` or `.iloc` in this case.

```{python}
durations_series.loc[0] == durations_series.iloc[0]
```

However, `.iloc` can be useful even when dealing with series with a numeric index. Just imagine the following series.

```{python}
user_series = pd.Series({
    42: "Aleks", 22: "Barbara", 1: "Carl"
})
```

<!-- TODO: mention in chapter on series construction that a series can be constructed using a dictionary, because we are using this in the code above! -->

To get the first element, we can write

```{python}
user_series.iloc[0]
```

without caring about the index labels. If we used `.loc` in this example, we would have to use the label `42`.

```{python}
user_series.iloc[0] == user_series.loc[42]
```

## Getting Multiple Elements of a Series Using `.iloc`

### Using a List

Just as `.loc`, the `.iloc` property allows us to access multiple elements at once. Again, we can use a list for this purpose. To get the third and fourth element of `row_series` we can write the following.

```{python}
row_series.iloc[[2, 3]]
```

For `durations_series`, the `.loc` and `.iloc` methods yield the same result again because the labels match the elements' position.

```{python}
durations_series.loc[[0, 1]] == durations_series.iloc[[0, 1]]
```

### Using a Slice

The `.iloc` also supports slicing, however, it differs from slicing with `.loc`. Can you spot the difference when looking at the following two snippets?

```{python}
durations_series.iloc[0:1]
```

```{python}
row_series.iloc[1:3]
```

Exactly! The upper bound of the slice is not included when using `.iloc`. Since `.iloc` works with positions, the Pandas developers decided it would be most intuitive if it works in the same way as standard Python where the element corresponding to the upper bound of a slice is not returned.

Now we know how to access a single or multiple series elements using `.loc` and `.iloc` üéâÔ∏è In the next chapter we'll revisit `.loc` to see what may be its most powerful ability. <!-- todo: ensure the next chapter is really about .loc (in connection with Boolean series) -->

::: {#exr-series-iloc-replicate-head}

Use positional indexing to write a `head()` function that replicates the behavior of the `.head()` method.

```{python}
#| eval: false
def head(series, number_of_elements_to_show=5):
    return # TODO: finish return statement

head(durations_series, 3)
```

You can compare your solution to @sol-series-iloc-replicate-head.
:::
